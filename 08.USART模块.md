# 单片机总结系列(8) USART模块

## USART模块和通讯接口

USART(通用同步异步收发器)是可以灵活的与外部设备进行数据交互的，支持全双工和半双工，同步和异步收发的通讯模块。USART在嵌入式产品中应用广泛，通过调试信息，连接蓝牙，wifi等外设模块，通过自定义协议和其它设备交互，都可能使用到USART接口。

### 通讯接口详解

USART对于芯片I/O输出的是TTL电平，不过为了可靠性，也可以通过外部扩展支持RS232, RS485和RS422等多种通讯接口, 在进行连接时一定要注意不能混用，否则有损坏器件的风险。

- TTL是芯片I/O输出的电平，因此对于逻辑电平和I/O的检测一致，即**电压0v表示逻辑0，电压3.3v表示逻辑1**。 TTL的RX，TX分开独立工作，所以为全双工，不过TTL为纯芯片的I/O输出控制，抗干扰能力差，所以主要用于短距离通讯，如板内的芯片通讯，或者仅作为调试口打印输出.
- RS232在软件使用上基本和TTL一致，所以也是全双工通讯，在设备的两端都增加转换芯片(如MAX232)进行了电平的转换，即**电压+3~+15V表示逻辑0，电压-3~-15V表示逻辑1**，这样电平的差值可以很大概率防止翻转，增强了抗干扰能力，可以一定程度上增加传输距离，一般用于20m以内的板间传输，也是在硬件设计中常用的开发中常用的器件.
- RS485则是将TX，RX信号转换为差分的A， B两个信号，根据A, B两个信号的电平差值进行区分，**电压差为+2~+6V表示逻辑1, 电压差为-2~-6V表示逻辑0**, 通过差分提高了抗共模能力，因此抗干扰能力比RS232更强，传输距离更远。不过RS485需要通过I/O控制接收和发送，所以RX和TX同时只有一个能工作，因此只能半双工，适合应用于主从通讯的模式.
- RS422则是由两路RS485分别处理TX和RX信号，RX和TX能够同时工作，因此和RS232一样支持全双工通讯，且和RS485一样具有较强的抗干扰能力，支持远程传输，不过器件价格也会更高，需要根据应用需求选择使用。

上面讲解了硬件相关的知识，可以发现如果错误的将不同接口进行连接，就会将错误的电平加载到器件或芯片上，发生损坏，所以在使用中一定要确认，特别是现在USB转串口模块并没有说明，很容易发生问题。

### 串口特性说明

对于USART特性中比较重要的就是串口基础特性.

- 波特率，设备两端约定的用于解析数据的时序，常用的有115200, 57600, 9600等，如果双方设定不一致则没法正常解析数据。
- 数据位，定义通讯中数据位的长度，一般支持7/8bit数据，对于STM32的串口来说，配置的是字长(数据位+可选的奇偶校验位), 且只支持8/9bit, 也就是以8bit数据位为例，**不开奇偶校验位，字长配置位UART_WORDLENGTH_8B，开启后配置为UART_WORDLENGTH_9B**, 需要格外注意.
- 停止位，定义结束位的长度，支持1/2/0.5/1.5个停止位，其中最常用的停止位为1.
- 奇偶校验位，包含奇校验，偶校验和无校验三个模式，其中奇校验用于满足数据内部有奇数个1，偶校验类似，无校验则只发送数据位。

知晓了串口的波特率，字长和停止位信息，大致可以计算出串口接收一个字节需要的时间，以115200波特率，8bit字长，1个停止位为例，一个字节需要时间为1/115200\*(1 + 8 + 1)\*10^6us=86.8us，就需要快速进行接收读取。而9600比特率，一个字节传输需要时间为1/9600\*(1 + 8 + 1)\*10^3ms=1.04ms，发送完成一个字节就需要占用大量时间，因此产品应用时就要根据实际情况进行配置使用。

- 高波特率的应用，使用轮询或者中断接收，就需要保证在86.8us内将USARTx->DR内数据读出，否则就会发生ORE(Overrun error), 发生数据丢失，在实际应用中，可以降低波特率，如9600就差不多1ms接收一个字节数据，或者直接使用DMA+空闲中断读取。
- 对于低波特率通讯应用，则发送会占用大量时间，这时就适合使用缓存+发送完成中断模式或直接使用DMA发送数据。

### 串口流控功能

对于串口来说，硬件流控虽然并不是常用的功能，但在某些情况下，通过流控，接收端可以控制发送端的数据发送，当数据未出时，让发送端等待，避免数据发出，从而避免溢出导致的数据丢失，此外也可以对于低功耗设备间的通讯，也可以通过CTS引脚限制先上电设备的通讯，避免在启动时的串口数据导致芯片工作异常，对于STM32芯片的流控设计，两端的功能如下.

1. nRTS对应RX数据端，即接收引脚，低有效，如果打开RTS流控，则在接收到数据且未读出时(RXNE置位)，RTS对应I/O拉高，当数据读出时拉低。
2. nCTS对应TX数据端，即发送引脚，低有效，如果打开CTS流控，且检测到CTS为高电平，则下一帧数据不被发出，知道检测到CTS为低电平。

我们正常使用中，就是将发送端的nCTS和接收端的nRTS连接，这样当接收端收到数据未读出时，就会拉高nRTS, 同时发送端的nCTS也会拉高，则停止发送数据(此时TXE和TC不会置位，发送时会检测这两个状态)，当接收端读出后，则拉低nRTS，发送端的nCTS也会拉低，这时数据可以发送，从而确保接收端数据不会溢出，流控功能需要发送端和接收端同时支持才能正常工作，因此至少需多占用发送端和接收端各一个指定I/O。

## 使用STM32的USART通讯应用

### USART基础收发

使用USART模块进行数据收发并不困难，按照单片机开发的通用流程：

1. 使能GPIO和USART模块的时钟。
2. 配置对应GPIO，以及USART模块，符合工作的要求。
3. 调用发送和接收接口完成usart数据的接收和发送。

其中初始化部分HAL库的实现的没有问题，不过对于数据发送和接收，可以看到上面对效率是有要求的，特别是中断中，而STM32的HAL库实现的就特别冗余，我个人更习惯标准库的写法，具体实现如下.

```c
//1.USART功能配置
//初始化UART对应的I/O
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(huart->Instance==USART1)
  {
    //使能GPIO和USART1的时钟
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_USART1_CLK_ENABLE();

    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
  }
}

//配置USART模块功能
BaseType_t usart_hardware_init(void)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;                    //波特率115200
    huart1.Init.WordLength = UART_WORDLENGTH_8B;      //数据为8bit
    huart1.Init.StopBits = UART_STOPBITS_1;           //停止位
    huart1.Init.Parity = UART_PARITY_NONE;            //奇偶校验位关, 如果开且发送8bit, 需要配置为UART_WORDLENGTH_9B
    huart1.Init.Mode = UART_MODE_TX_RX;               //支持串口发送接收
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;      //不使用流控
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;  //定义波特率寄存器小数位的数目(值越大精度越高)
    if (HAL_UART_Init(&huart1) != HAL_OK)
        return pdFAIL;
    
    return pdPASS;    
}

//2.封装接收数据和发送数据接口
uint16_t UART_ReceiveData(UART_HandleTypeDef* huart)
{
  uint16_t rx_data;
  
  rx_data = huart->Instance->DR&0x1FF;
  
  return rx_data;
}

void UART_SendData(UART_HandleTypeDef* huart, uint16_t Data)
{
  huart->Instance->DR = Data&0x1FF;
}

//3.测试UART循环等待发送
void usart_loop_test(void)
{
  uint16_t rx_data;
  while(1)
  {
    if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_RXNE) != RESET)
    {
      //等待数据接收
      rx_data = UART_ReceiveData(&huart1);

      while(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_TXE) == RESET)
      {}

      //将接收数据发送
      UART_SendData(&huart1, rx_data);
    }
  }
}
```

上述代码就是最简单的串口数据收发，不过在串口通讯只是产品功能中的一部分，花费大量时间在处理数据发送，以及通过循环及时的读取数据会占用了大量的资源，除非自带硬件FIFO的嵌入式MCU，否则这种直接读取的方式不适合大部分应用场景，在实际产品中使用中断收发或者DMA收发来减少资源占用和提高效率。

### USART的中断收发

在实现USART的中断收发前，了解支持哪些中断比较重要，USART的SR寄存器显示了支持的状态，如果相应中断位使能，则会触发对应中断，对于USART通讯相关，主要有以下状态说明。

- USART异常状态位，PE，FE, NE，ORE， 这些都是异常状态，**可通过读SR，然后再读DR清除**，这些状态位的处理可以提高USART的稳定性
- RXNE，读数据寄存器非空
- IDLE，空闲状态位，当检测到总线空闲时，置位'1'，**可通过读SR，然后再读DR清除**, 在说明中有**IDLE位不会再次被置高直到RXNE位被置起**,这就表示只有收到数据后，在检测到空闲帧(一个数据帧长度，上面提到的起始位+数据位+停止位的时间一直保持高，则认为空闲), 才会触发，主要配合DMA使用，这在下小节详细讲解。
- TXE, 发送数据寄存器为空时置位'1', 当有数据写入时自动清零，也是我们使用中断发送的需要检测的中断。
- TC, 发送完成，当帧完全发送时置位，通过读SR,写DR清零，也可以直接写'0'清除。看到这里可能疑惑为什么有TXE后，还有TC，这里讲解下，对于USART的发送，数据从TDR->发送移位寄存器->经过电平转换和波特率控制按位在通讯线上发送。当TDR数据进入移位寄存器时，TXE即置位，而等此数据的所有时序发送完后，TC才置位，中间基本相差一帧的时间。对于大部分场景，都是使用TXE来发送数据，不过对于RS485应用，因为发送后要切换成接收模式，此时就只能检测TC而不是TXE，因为TXE置位时，最后一个字节可能还未发出，就会导致出错，其它应用则基本不用考虑这个区别。
- CTS标志，当CTS引脚状态发生变化时，该位被硬件置高，流控使用时用于检测是否能够发送。

上面包含了基本全部会使用的所有USART状态信息，对于我们的中断收发，主要用到RXNE和TXE两个状态触发的中断，因为I/O使用一致，所以GPIO的初始化不在重复，下面是基于中断开发的应用。

```c
//GPIO和USART接收发送函数参考上节说明

//配置USART模块功能
BaseType_t usart_hardware_init(void)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;              
    huart1.Init.WordLength = UART_WORDLENGTH_8B;    
    huart1.Init.StopBits = UART_STOPBITS_1;        
    huart1.Init.Parity = UART_PARITY_NONE;          
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    if (HAL_UART_Init(&huart1) != HAL_OK)
        return pdFAIL;
    
    //开启USART接收非空中断和发送完成中断
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 1);
    return pdPASS;    
}

void circular_push_fifo(void *fifo, uint8_t data);
uint8_t circular_pop_fifo(void *fifo);
uint8_t circular_check_fifo_empty(void *fifo);
uint8_t circular_check_fifo_full(void *fifo);

//usart中断接收处理
void USART1_IRQHandler(void)
{
  uint16_t data;

  if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_RXNE) != RESET)
  {
    data = UART_ReceiveData(&huart1);
    circular_push_fifo(&rx_fifo, data);
  }

  //有关闭TXE的动作，当RXNE触发时，有可能误触发TXE
  //所以需要检测TXE是否开启
  if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_TXE) != RESET
  && __HAL_UART_GET_IT_SOURCE(&huart1, UART_IT_TXE))
  {
    if(circular_check_fifo_empty(&tx_fifo))
    {
      __HAL_UART_DISABLE_IT(&huart1, UART_IT_TXE);
    }
    else
    {
      data = circular_pop_fifo(&tx_fifo);
      UART_SendData(&huart1, data);
      if(circular_check_fifo_empty(&tx_fifo))
      {
        __HAL_UART_DISABLE_IT(&huart1, UART_IT_TXE);
      }
    }
  }
}

void usart_fifo_send(uint8_t data)
{
  //如果检测到fifo满，则使用堵塞的方式从fifo取数据发送
  //正常工作发送设计上应该保证fifo不应该满，如果满说明发送效率太低或者FIFO定义不合理
  //此时建议提高波特率、降低发送频率或者加大FIFO三方面进行调试
  if(circular_check_fifo_full(&tx_fifo))
  {
    uint8_t data;

    __HAL_UART_DISABLE_IT(&huart1, UART_IT_TXE);
    data = circular_pop_fifo(&tx_fifo);
    
    while(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_TXE) == RESET)
    {}
    UART_SendData(&huart1, rx_data);
  }

  __disable_irq();
  circular_push_fifo(&tx_fifo, data);
  __enable_irq();

  __HAL_UART_ENABLE_IT(huart1, UART_IT_TXE);
}

void usart_loop_test(void)
{
  uint16_t rx_data;
  while(1)
  {
    //对于接收和发送因为都是由缓存处理，所以在主循环操作时，
    //即使其它地方导致延时2-3ms，仍然能够正确处理，从而保证数据不会丢失
    if(circular_check_fifo_empty(&rx_fifo) != 0)
    {
      data = circular_pop_fifo(&rx_fifo);
      usart_fifo_send(&huart1, &tx_fifo, data);
    }
  }
}
```

上面就是基于USART的接收和发送中断并配合收发FIFO实现的数据通信，比起直接的等待所有数据发出，通过FIFO缓存就不用考虑无法及时读取发送串口的溢出，发送时也不需要等待，从而避免大量时间的占用，对于打印logger调试信息信息，接收串口命令处理都方便处理，是开发中常用的处理方式。不过并不是没有弊端。

- 接收和发送数据都会触发中断，虽然不用等待，大部分应用问题不大，但对于多资源访问的应用，也仍然占用一部分时间。
- 对于高波特率高频通讯，如果有其它中断占用时间过长，仍然可能导致USART有溢出风险

为了解决上述两个问题，就可以使用DMA实现USART数据接收和发送，可以避免上述问题。

### USART的DMA+空闲中断接口，DMA发送

在上小节我们已经讲了空闲标志位，以及空闲中断的说明，这里先从DMA说起。无论是上面的轮询接收还是中断接收，其原理核心都是如下步骤。

- 接收部分，外部数据输入->RDR寄存器，置RXNE标志位->通知内核(中断或者查询)->内核从RDR读取数据写入RAM中
- 发送部分，内核查询TXNE标志位->判断满足写入要求->MCU从RAM中取出数据，写入TDR寄存器->数据输出

也就是无论是数据的接收还是发送都需要内核的参与，即使中断模式，只是不用等待数据移位发送的时间，具体的操作还是需要占用内核资源去执行的，对于DMA，则取代了内核的参与，通过DMA就可以完成了数据的收发，采用DMA模式，数据就变成了如下方式。

- 接收部分，外部数据输入->RDR寄存器，置RXNE标志位->通知DMA模块->DMA从RDR寄存器取出数据，写入到目的RAM中->满足一定条件后，通知内核，此时内核就可以获得完整帧
- 发送部分，设置源端地址和长度,DMA启动搬运->发送寄存器为空时，触发DMA搬运->DMA从RAM中取出数据，写入TDR寄存器->数据输出->重复发送过程，直到关闭DMA或者到达指定发送长度。

从这个流程可以看出DMA的参与后，所有的发送和读取由DMA完成，只有在发送和接收完成才需要去处理相应中断，大大降低了资源占用，不过使用DMA模式后，一定不要使用超时等待DMA发送完成，而是查询DMA和USART状态，判断是否发送完成，这样才可以提高效率。对于USART的DMA模式，支持发送和接收两种模式，对于DMA的应用主要包含以下步骤。

1. 配置USART相关功能(USART和GPIO)，能够正常串口通讯。
2. 开启USART的DMA接收和发送。
3. 配置DMA通道，这个参考DMA通道表格，USART1_RX - DMA2_Stream2/DMA_CHANNEL_4, USART1_TX - DMA2_Stream7/DMA_CHANNEL_4, 进行DMA的配置。
4. 对于DMA的发送，比较好理解，将源端和目的地址写入到对应寄存器，在写入长度，开启后即可进行发送，发送完成即可触发DMA_TC中断，此时关闭DMA，后续就可以开始第二次发送。
5. 对于DMA的接收，同样的开启DMA接收传输，理论上也是要设置长度受到TC中断，这就需要基于USART的空闲中断判断截至的时间，可以读出剩余的数据长度。

```c
//GPIO和USART接收发送函数参考上节说明
//配置USART DMA模块功能
BaseType_t usart_hardware_init(void)
{
    __HAL_RCC_DMA2_CLK_ENABLE();

    //1.usart模块初始化
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    if (HAL_UART_Init(&huart1) != HAL_OK)
        return pdFAIL;
    
    //空闲中断使能
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 1);
    
    //使能USART DMA的发送和接收
    ATOMIC_SET_BIT(huart1.Instance->CR3, USART_CR3_DMAT);
    ATOMIC_SET_BIT(huart1.Instance->CR3, USART_CR3_DMAR);
           
    //2.配置DMA的接收
    hdma_usart1_rx.Instance = DMA2_Stream2;
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_rx.Init.Mode = DMA_NORMAL;
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
    hdma_usart1_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
    hdma_usart1_rx.Init.MemBurst = DMA_MBURST_SINGLE;
    hdma_usart1_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
    {
      return pdFAIL;
    }
    __HAL_LINKDMA(&huart1, hdmarx, hdma_usart1_rx);
    
    //启动DMA的接收
    HAL_DMA_Start(&hdma_usart1_rx, (uint32_t)&huart1.Instance->DR, (uint32_t)dma_rx_buffer, DMA_BUFFER_SIZE);
    
    //3.配置DMA的发送
    hdma_usart1_tx.Instance = DMA2_Stream7;
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_tx.Init.Mode = DMA_NORMAL;
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
    hdma_usart1_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
    hdma_usart1_tx.Init.MemBurst = DMA_MBURST_SINGLE;
    hdma_usart1_tx.Init.PeriphBurst = DMA_PBURST_SINGLE;
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
    {
      return pdFAIL;
    }
    __HAL_LINKDMA(&huart1, hdmatx, hdma_usart1_tx);
    
    //enable uart idle interrupt
    __HAL_DMA_ENABLE_IT(&hdma_usart1_tx, DMA_IT_TC);
    HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);
    HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 1);
    return pdPASS;    
}

//启动DMA的发送
void usart_translate(char *ptr, uint16_t size)
{
  memcpy((char *)dma_tx_buffer, ptr, size);
  
  HAL_DMA_Start(&hdma_usart1_tx, (uint32_t)dma_tx_buffer, (uint32_t)&huart1.Instance->DR, size);
} 

void DMA2_Stream7_IRQHandler(void)
{
    if(__HAL_DMA_GET_FLAG(&hdma_usart1_tx, DMA_FLAG_TCIF3_7) != RESET)
    {
        //clear all flags
        __HAL_DMA_CLEAR_FLAG(&hdma_usart1_tx, DMA_FLAG_TCIF3_7);
        __HAL_DMA_CLEAR_FLAG(&hdma_usart1_tx, DMA_FLAG_TEIF3_7);
        
        //close the dma tx for next  
        HAL_DMA_Abort(&hdma_usart1_tx);
        __HAL_DMA_ENABLE_IT(&hdma_usart1_tx, DMA_IT_TC);
    }
}

//usart中断接收处理
void USART1_IRQHandler(void)
{
    uint8_t data;
    
    if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE) != RESET)
    {
      __HAL_UART_CLEAR_PEFLAG(&huart1);
      
      HAL_DMA_Abort(&hdma_usart1_rx);
      
      gRxInfo.is_rx_dma = 1;
      gRxInfo.rx_size = DMA_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);
    }
}

static void usart_run_test(void)
{
  char data[DMA_BUFFER_SIZE];
  
  while(1)
  {
    if(gRxInfo.is_rx_dma == 1)
    {
        memcpy(data, dma_rx_buffer, gRxInfo.rx_size);
        gRxInfo.is_rx_dma = 0;
        
        HAL_DMA_Start(&hdma_usart1_rx, (uint32_t)&huart1.Instance->DR, (uint32_t)dma_rx_buffer, DMA_BUFFER_SIZE);
        usart_translate(data, gRxInfo.rx_size);
    }
  }
}
```

通过DMA，可以替代内核的数据发送，提高了效率，不过从上面可以看出，只有以帧的形式进行收发，才能够发挥效用，在实际的产品中，能够根据实际情况选择才最重要.
